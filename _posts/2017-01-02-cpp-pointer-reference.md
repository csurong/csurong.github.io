---
layout: post
title:  "引用和指针的辨析"
date: 2017-01-02 02:01:21 +0800
categories: C++
tags:  ACM c++
author: csurong
---

* content
{:toc}

指针指向内存地址，引用则是变量的一个别名




## 区别

+ pointer 是一个实体，它指向内存地址，真正的主角。而引用相当于是给变量起了另一个名字
+ 引用使用时不需要解引用(\*)；指针则需要
+ 引用在初始化后便不可变；指针可变。名字不会改，但地址可能会改
+ 引用没有 const，指针有 const，const 的指针不可变；
+ 引用不能为空，指针可以为空；
+ `sizeof 引用`得到的是所指向的变量(对象)的大小，而`sizeof 指针`得到的是指针本身(所指向的变量或对象的地址)的大小；`typeid(T) == typeid(T&)` 恒为真，`sizeof(T) == sizeof(T&)` 恒为真，但是当引用作为成员时，其占用空间与指针相同（没找到标准的规定）。
+ 指针和引用的自增(++)运算意义不一样

## 联系

+ 引用在语言内部用指针实现
+ 对一般应用而言，把引用理解为指针，不会犯严重语义错误。引用是操作受限了的指针（仅容许取内容操作）。
+ 引用是C++中的概念，初学者容易把引用和指针混淆一起。以下程序中，n 是m 的一个引用（reference），m 是被引用物（referent）
```c++
int m;
int &n = m;
```

n 相当于m 的别名（绰号），对n 的任何操作就是对m 的操作。例如有人名叫王小毛，他的绰号是“三毛”。说“三毛”怎么怎么的，其实就是对王小毛说三道四。所以n 既不是m 的拷贝，也不是指向m 的指针，其实n 就是m 它自己。

引用的一些规则如下：
+ 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）
+ 不能有NULL 引用，引用必须与合法的存储单元关联（指针则可以是NULL）
+ 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）以下示例程序中，k 被初始化为i 的引用。语句k = j 并不能将k 修改成为j 的引用，只是把k 的值改变成为6。由于k 是i 的引用，所以i 的值也变成了6

```c++
int i = 5;
int j = 6;
int &k = i;
k = j; // k 和i 的值都变成了6; 
```

## 使用

引用的主要功能是传递函数的参数和返回值。C++语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递

以下是“值传递”的示例程序。由于Func1 函数体内的x 是外部变量n 的一份拷贝，改变x 的值不会影响n, 所以n 的值仍然是0
```c++
void Func1(int x)
{
	x = x + 10;
}
int n = 0;
Func1(n);
cout << "n = " << n << endl;	// n = 0 
```

以下是“指针传递”的示例程序。由于Func2 函数体内的x 是指向外部变量n 的指针，改变该指针的内容将导致n 的值改变，所以n 的值成为10
```c++
void Func2(int *x)
{
	(* x) = (* x) + 10;
}
...
int n = 0;
Func2(&n);
cout << "n = " << n << endl;	// n = 10 
```

以下是“引用传递”的示例程序。由于Func3 函数体内的x 是外部变量n 的引用，x和n 是同一个东西，改变x 等于改变n，所以n 的值成为10
```c++
void Func3(int &x)
{
	x = x + 10;
}
...
int n = 0;
Func3(n);
cout << "n = "<< n << endl; // n = 10 
```

从上面三个例子，可以看出“引用传递”的性质就像“指针传递”，而书写方式却像“值传递”。实际上“引用”可以做的任何事情“指针”也都能够做，之所以出现引用这东西可以简单的概括为“杀鸡焉用宰牛刀”。毕竟指针是有主角光环的，它能够毫无约束地操作内存中的如何东西，因此尽管功能强大，但同时从使用角度来说也非常危险。当代码中只需要使用某个对象的“别名”，那么就用“引用”，尽量避免使用“指针”，以免犯大错

## 参考

* https://www.zhihu.com/question/37608201

* C++ Primer

---
layout: post
title:  "黑马"
categories: JavaScript
tags:  font-end JavaScript
author: csurong
---

* content
{:toc}


## Linux

### 命令
+ UNIX不开源。MIUNIX用于教学。Linux发展于MIUNIX

+ `sudo apt-get install name` `sudo apt install`
+ 备份Ubuntu默认源地址 `sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup`
+ 更新源服务器列表，即 `/etc/apt/sources.list`
+ `sudo apt-get update` sudo apt install 
+ `sudo apt-get remove name` 删除包
+ `sudo apt-cache search package` 搜索软件包
+ `sudo apt-cache show package`  获取包的相关信息，如说明、大小、版本等


+ ls 
+ Linux命令格式：命令 选项 参数
+ ls -alh a(所有) l(详细显示) h(人性化显示)
+ ls --help   man ls

+ 重定向（覆盖） ls > a.txt 把输出的内容放到a.txt文件里
+ 追加 ls >> a.txt
+ more f键翻页

+ 管道 ls -alh /bin | more 将上一个的结果传递给下一个命令

+ cd - 进入上次所在目录
+ cd 进入当前用户主目录 与 cd ~ 一样

+ cat 查看
+ grep -n 'aa' a.txt  文本搜索 -v求反 -n显示行数 -i忽略大小写

+ ctrl+c 命令行直接换行

+ mkdir -p a/b/c/d

+ 硬链接 `ln 源文件 链接文件` 相同大小，源文件没了照样可以
+ 软链接 `ln -s 源文件 链接文件` 不占用磁盘空间，没了就失效 

+ `find 路径 -name(size等) 文件`
+ .tar `tar -cvf -xvf`  .tar.gz `tar -czvf -xzvf`  (cvf 为 .tar，加 z 为 .tar.gz, 加 j 为 .tar.bz2)

+ 类Unix没有盘符的概念，只有目录
+ bin 文件夹跟程序相关
+ boot 文件夹跟系统开机启动相关
+ dev 跟设备相关（外接设备）
+ etc 几乎所有程序配置的地方
+ lib 放的一些库  
+ home 中的家目录.home文件夹中存放的是用户文件夹
  
+ cal 显示本月日历 `cal -y 2018`
+ date 查看当前时间

+ ps 查看当前进程 ps -aux
+ top、htop
+ kill 杀进程  `kill -9` 强制结束

+ reboot 重启
+ shutdown -h now 关机
+ shutdown -h 22:25 二十二点二十五分关机
+ shutdown -h +10 再过十分钟自动关机

+ df 检测磁盘空间
+ du 检测目录所占磁盘空间
了
+ ifconfig
+ ping

+ useradd -m 新建用户并创建用户目录
+ 查看实际有几个用户 cat /etc/passwd/
+ userdel
+ passwd
+ su
+ whoami
+ exit

+ 打开新的终端标签页 ctrl + shift + T。用 alt + 数字 切换
+ ubuntu 中切换管理员 sudo -s

+ 用户，用户组 [相关概念](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/linux%E5%9F%BA%E7%A1%80/01day/section.3.2.html)

+ d 文件夹
+ rwx 可读可写可执行 421
+ r-- 只可读

### vim
+ 默认命令模式。按 i 进入插入模式。
+ 按 esc 进入命令模式
+ 命令模式按 冒号 进入末行模式 q！不保存退出

### 服务器
+ ftp服务器 ftp文件传输协议
+ samba服务器
+ ssh和scp
+ 以上三种服务器的配置[地址](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/linux%E5%9F%BA%E7%A1%80/02day/section.4.html)


## python 基础

### 命令行
+ ipython3 退出 exit 不行就用 exit()

### python2的中文
+ python2 中不认中文，要在第一行加上 `#coding=utf-8` 或者 `-*- coding: utf-8 -*-`(推荐)

### python 语法查漏补缺
+ input() 输入的都是字符串
+ print() 中的 end 属性指定结束符
+ type(a) 看 a 的类型
+ [常用的数据类型转换](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/Python%E5%9F%BA%E7%A1%80/03day/section.10.html)
+ / //(商，返回整数部分) * **(幂)
+ 可以用 >= 这种符号
+ 逻辑运算符 not
+ 复合运算符 += *=  /=
+ python中的运算符：
    + 位运算：& | ^ ~
    + 逻辑：and or not
    + 成员: in    not in
    + 身份：is    is not 是否引用自一个对象
+ \t 排版对齐
+ 不换行 end='' 换行 print('')
+ random 需要导入， range是内置的
+ 字符串的数组表示 name name[0]='n'
+ 字符串的切片；第一个冒号后省略则截至点看步长的正负值，正为最右（包括），负为最左（包括）
+ `字符串.` 即可调出相关方法
+ a.split() 什么都不写，默认切割空白字符，空格\t都是
+ 列表的增删改查 
    + 增 append(整体) insert extend(合并)
    + 删 pop remove del
    + 改 [下标]
    + 查 'aa' in listname   not in
+ 列表嵌套字典。字典存储相关信息（姓名，年龄等），存储到列表中
+ 对列表的 for-in 两种情况： 一是 range 的数字，二是列表项
+ 标记 flag 的灵活使用
+ 字典的增删改查：
    + 增 dict['key1']='value1' key必须是字符串、数字等不可变对象。即列表、字典不可以
    + 删 del dict['key1']
    + 改 dict[key1]='value2'
    + 查 dict.get('key1') 查的是键，得到的是值，没有就是 None
+ 元祖可以按顺序赋值 c,d = a
+ 函数返回多个值
+ 随大流走，用到函数再定义函数
+ 使用 global 对全局变量声明。说明不是定义局部变量，而是对全局变量的修改
+ 缺省参数，给了个默认值（省的给了）。可以给命名参数
+ 调用时形参可以给命名参数。都可以
+ 不定长参数（可变参数） *args。多余的以元祖传给 args
+ 不定长参数（关键字参数） **kwargs。多余的以字典的形式给 kwargs。必须是命名参数
+ 拆包。若要传给函数元祖和字典，需在实参前加 * 和 **。
```python
def test(a, b, *args, **kwargs):
    print(a)
    print(b)
    print(args)
    print(kwargs)
    
A = (2,3,4)
B = {'name': 'surong', 'age': 24}

test(11, 22, *A, **B)
# test(11, 22, (2,3,4), {'name': 'surong', 'age': 24})
```
+ 引用。一切变量都是引用。尽量不要用  a=100 b=a 这种形式
+ 可变类型：列表和字典，可以修改。所以不可以用作字典的 key
+ 内存溢出。内存占用空间过大，操作系统直接 kill 它，即闪退
+ in。判断字符串、列表、元祖、字典的键。'name' in {'name': 'csurong'} True
+ 匿名函数，lambda `sum = lambda arg1, arg2: arg1+arg2  sum(10, 20)`
+ 匿名函数可以做函数调用时的实参
+ sort方法的相关操作
+ eval(intput_str) 把输入的字符串转成了语句。用来执行一个字符串表达式，并返回表达式的值
+ num+=num 并不等于 num=num+num ，数字上是一样的。但 前者是左边先算，若能改就改了。后者是右边先算，重新开辟了一片内存让左边num重新指向新内存
+ 打开文件：f = open(文件名， [访问模式](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/Python%E5%9F%BA%E7%A1%80/08day/section.2.html))
    + r 只能读(默认)
    + w 只能写
    + a 追加写入 add
    + 以上三个后面直接加 d。文本文件，二进制文件（图片，视频，音频）
    + 以上三个后面直接加 + ，可以读写
        + r+ 指针放文件开头
        + w+ 文件若存在则覆盖。不存在则自动创建
        + a+ 追加
    + rb+ wb+ ab+ 二进制读写
+ 关闭文件 f.close()
+ 读：
    + f.read() 全读
    + f.read(1) 一个一个读 f.read(20)
    + f.readline() 一行一行读
    + f.readlines() 用列表存每一行
    + 读大文件，考虑内存问题
```python
while True:
    content = old_file.read(1024)
    
    if len(content) == 0:
        break
    
    new_file.write(content)
```
+ 写：
    + f.write('yes\nno')
+ 文件定位读写：
    + f.tell() 获取文件当前指针的位置
    + f.seek(offset, from)
        + offset 偏移量
        + from 0是文件开头，1是当前位置，2是文件末尾。指定标量指针位置
+ os库，[文件、文件夹的相关操作](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/Python%E5%9F%BA%E7%A1%80/08day/section.5.html)

+ 类和对象
+ 类名命名形式用大驼峰
+ 定义 class Cat：  创建新的对象 tom = Cat()
+ __str__ return的是什么，打印的就是什么
+ 类（这个类的引用比较准确）传入另一个类的方法中
+ 不要直接让用户获取属性，最好使用方法返回属性
+ 私有方法，方法前加 __ 不能直接调用。公有方法内部才能调用私有方法
+ del 删除对象，实质是删除的是类的引用。
+ __del__ 对象删除时调用此方法
+ sys模块中的**方法，可以显示引用计数，比实际多1
+ 重写。在子类定义和父类中同名的方法。若要调用父类中同名的方法，则 父类名.方法名(self) 或者 super().方法名()
+ 私有方法、属性不会被子类继承。但可以通过公有方法去调，主要看去调的对象是谁
+ 多继承，继承多个父类
+ 没有父类，写成新式类的形式 class Base(object)。python3默认新式类，不加object也可以。总结有三种： class Base(); class Base(object); class Base;
+ __mro__ 查看搜索的路径和顺序
+ **多态**
+ 类属性。多实例对象共享。直接定义。 使用：类名.类属性+=1.不能通过实例去直接调用修改,这样修改的实际是实例对象属性,要通过 类.类属性 修改
+ 类对象、实例对象
+ 类方法：@classmethod（装饰器） cls。 类方法可以通过 类名 或者 类创建出来的实例对象 去调用
+ 实例方法：self
+ 尽量不要既有类又有函数。此时考虑实例方法
+ 静态方法 @staticmethod 不用任何参数。一般是和对象没有强关系的函数使用静态方法
+ 静态方法通过 类名 或 实例方法 调用

+ 不可能一步到位，都是边写边改进
+ **设计模式 《python设计模式》 工厂模式**
+ __new__ 方法。作用就是创建实例对象,并返回
    1. 创建一个对象  __new__ 方法。返回值表示创建对象的引用。只负责创建
    2. 调用 __init__ 方法。该引用传入__init__。只负责初始化
    3. 返回对象的引用
    + C++中的构造方法包含了创建和初始化，python中实际上是两个方法
+ 为何重写 __new__ 方法
+ 所谓**单例**，不管创建多少个实例对象，都指向同一个
```python
# 创建单例对象
class Dog(object):
    __instance = None #初始化为 None 可以双用。既为计数，又能再赋值
    
    def __new__(cls):
        if cls.__instance == None:
            cls.__instance = object.__new__(cls)
            return cls.__instance
        else:
            return cls.__instance
```
+ 凡是和 None 比较，必须用 is 或者 is not，不能用 == !=
+ 单例。为了使类中的 __init__ 执行一次之后都不执行，防类构建实例时改变变量
```python
class Dog(object):

    __instance = None
    __init_flag = False
    
    def __new__(cls, name):
        if cls.__instance is None:
            cls.__instance = object.__new__(cls)
            return cls.__instance
        else:
            return cls.__instance
            
    def __init__(self):
        if Dog.__init_flag == False:
            self.name = name
            Dog.__init_flag = True
            # 不管实例化几次，都是最初的名字
```

+ 异常处理
```python
try:
    xxx
except 异常名字：# 若要多个异常，要用元祖，单用逗号分隔会报错
    异常发生后的处理
else:
    没有异常才会执行的功能
finally:
    不管是否有异常都会执行
    
# except Exception: Exception是所有异常的总称
# except 异常名字 as 自定name: 这个 自定name 就是产生这个异常的核心原因，可以输出或怎么着

```
+ try 可以嵌套
+ import time time.sleep(1) 1s
+ 异常传递。函数中的异常可以传递给调用它的函数
+ 抛出自定义异常。自己定义类，继承自 Exception。用 raise 抛出异常
+ 重新抛出异常。直接用 raise。自己不处理，在 raise 前做一些自己的事情，然后直接用 raise 抛出

+ 模块
+ .pyc 文件。把翻译过的import文件以字节码存储，节省之后运行的时间
+ 导入一个模块，实际是把这个模块从头到尾执行一遍
+ if __name__ == '__main__':
    + __name__ 的特性。别人导入的你，打印出来的就是模块的名字。直接运行自己就是 __main__,字符串
+ 在模块中放入变量 __all__,可以设置别人可导入的东西
```python
__all__ = ['test1', 'test2'] #里面没有的东西用不了

def test1():
    pass

def test2():
    pass
```
+ 包。文件夹里放多个模块且有 __init__ 文件。
+ 包下创建一个 __init__.py 文件。让你可以导这个包
    + 在里面写入变量 __all__ .影响了 from xx import * 能导入什么模块
    + 再 from . import 模块 （python2 是直接 import 导入）。使得可以以格式 包.模块.函数 使用
+ 模块的[打包和发布](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/Python%E5%9F%BA%E7%A1%80/08day/section.8.1.html)

+ 给程序传参 程序中导入 import sys sys.argv即是给程序传的参数

+ 列表推导式 for in range(0,10) range(10) range(0,10,1) python2返回值是列表，python3要的时候再生成，节省内存
+ [i for i in range(1,10)] [i for i in range(1,10) if i%2==0]
+ [(i,j) for i in range(5) for j in range(6)]

+ 元祖不能改，集合还是能改的
+ 在一个对象中调用另一个对象输出，自动调用被调对象的 __str__

+ 集成显卡,显示占用内存.独立显卡,独立的
+ break 让循环结束; exit() 让程序结束;return让函数结束

+ 循环列表删自己的元素,会出现bug,主要是删掉之后马上会后面跟上,补上删掉的位置,后面出现漏删
+ 用两个列表可以解决这个问题.只有循环自己且删自己的时候才会出现这个问题

+ 先面向过程,再面向对象,最后抽取基类


## 高级
+ 设置 import 搜索路径；导入的模块修改后重新加载 [查看](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/python%E9%AB%98%E7%BA%A7/html%E7%89%88/python%E9%AB%98%E7%BA%A7-%E8%AF%BE%E4%BB%B6/03day/section.0.2.html)
+ 循环导入。你导入我，我导入你。解决方案，一是设计时解耦，二是导入语句需要导入时再导入
+ == 与 is 的区别：is 是引用比较，是否指向同一个对象。== 仅是比较内容是否相等
+ 浅拷贝：拷贝引用。深拷贝，不管有几层引用，都直接拷贝内容，新建了一片内存 import copy c=copy.deepcopy(a)
+ copy.copy() 只复制对象自身，不会递归复制其成员。，copy.deepcopy() 递归复制所有成员，直指要害
+ 私有化。变量、方法前加两下划线。私有属性、方法无法直接使用、继承，只能通过构造方法间接访问、修改
+ property属性（作用是使调用私有属性变得简单，可以直接用类似属性的方式调用函数）Python内置的@property装饰器就是负责把一个方法变成属性调用的
```python
class Test():
    def __init__(self):
        self.__num = 100
        
    def getNum(self):
        return self.__num
        
    def setNum(self, newNum):
        self.__num = newNum
        
    num = property(getNum, setNum)
    # get在前，set在后，只要写方法名就行了
    
t = Test()

t.num = 200 # 相当于调用了 t.setNum(200)
print(t.num) # 相当于调用了 t.getNum()
```
+ 使用装饰器
```python
class Test():
    def __init__(self):
        self.__num = 100
    
    @property
    def num(self):
        return self.__num
     
    @Num.setter   
    def num(self, newNum):
        self.__num = newNum
    
    # 以上两个都只要写变量名就行了，第二个setter要传一个参数
    # 方法名是一样的，装饰器不同
    
t = Test()

t.num = 200 # 相当于调用了 t.setNum(200)
print(t.num) # 相当于调用了 t.getNum()
```

+ 生成器 generator。一边循环，一边计算。
    + 创建方式。列表生成式的中括号改成小括号 (x for x in range(10))
    + 生成器是一个对象。只要遇到 yield 就停，并返回后面的值。
    + 把yield看成return就行了。注意函数中要有退出条件
    + yield 切换多任务
```python
生成器是这样一个函数，它记住上一次返回时在函数体中的位置。对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。
生成器不仅“记住”了它数据状态；生成器还“记住”了它在流控制构造（在命令式编程中，这种构造不只是数据值）中的位置。
生成器的特点：
    节约内存
    迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的
```
+ 迭代器 iterable(able可以)。可以用 for 循环访问的东西。list、生成器、string等等
    + 可以用 form collections import Iterable; isinstance(xxx, Iterable) 判断是否是可迭代对象
+ 闭包：
    + 调用 a 函数，返回 b 函数的函数名，同时 b 函数用了 a 函数中的变量（环境变量）
    + 环境变量的值是连续的，只要不去修改，就不会被销毁。修改了也是新建的，以前的还是可以使用
+ 语法糖：特殊功能的语法
+ 装饰器：
    + 闭包。少了环境变量。
    + 直接在要添加功能的函数前加上闭包的 @函数名 即可添加功能
    + 其实就是经过某些固定操作或设置之后，再执行我要执行的函数
    + 多个装饰器，装饰器的调用是从上到下按顺序的，但函数是从下到上的inner，即从最原始到完善。这么想，装饰器首先要有一个装饰对象才行
    + 只要python解释器执行到有装饰器的这行，就会自动进行装饰，而不是等到调用时再进行装饰
```python
@makeBold
@makeItalic
def test3():
    pass
```
+ 被装饰的函数有参数，则innerFunc也要给相同的参数，用不用不要紧，主要是里面的innerFunc可以理解为被装饰的函数，额外添加一些东西
+ **通用装饰器**：
```python
    def func(functionName):
        def func_in(*args, **kwargs):
            ret = functionName(*args, **kwargs)
            return ret # 若没有返回值，则返回 None
            
         return func_in
```
+ 带有参数的装饰器：装饰器（原始）外头再套一个
```python
def func_arg(arg)：
    def func(functionName):
        def func_in(*args, **kwargs):
            ret = functionName(*args, **kwargs)
            return ret    
         return func_in
    return func
    
@func_arg('hehe')
# 1. 先执行func_arg('hehe')函数，这个函数return的结果是func这个函数的引用
# 2. @func
# 3. 使用@func对需要的函数进行装饰
```

+ 命名空间：就是对一个名字起作用的范围
+ 查看全局变量 globals()      查看局部变量 locals()

+ 动态语言。静态语言运行前必须先编译
+ 动态添加属性和方法 [链接](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/python%E9%AB%98%E7%BA%A7/html%E7%89%88/python%E9%AB%98%E7%BA%A7-%E8%AF%BE%E4%BB%B6/01day/section.1.1.html)
+ 动态语言，运行过程中可以修改代码。静态语言，编译时已经确定好的代码，运行过程中不能修改
+ Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性

+ 元类，不是重点，我跳过了
+ 垃圾回收。python对小整数使用的都是同一个对象。单个字母也是这样
+ GC(Garbage collection) 垃圾回收。以引用计数为主，以隔代回收为辅
+ 内建属性：对象默认拥有的属性 __init__ __new__ __del__ __str__ __repr__ 等
+ __getattribute__
+ 生成器，用的时候再生成。迭代器，逐步迭代，可以用 for 的
+ map(func, 可迭代对象)    映射  
+ fliter(func, 可迭代对象) 过滤
+ reduce(func, value)           累积  reduce要从 functools 中引入
+ sorted()
    + 列表的 sort 方法。a.sort() a.sort(reverse=True)
    + sorted(可迭代对象, reverse=1) 还有key，函数名、排序种子
+ functools dir(functools)
+ [常用标准库](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/python%E9%AB%98%E7%BA%A7/html%E7%89%88/python%E9%AB%98%E7%BA%A7-%E8%AF%BE%E4%BB%B6/03day/section.4.html)
+ 拖库，把数据库给copy了一份下来

+ pdb 是基于命令行的调试工具
    + python3 -m pdb name.py
    + l（list） 显示当前代码  n（next） 向下执行一行 c（continue）继续执行代码 b添加断点 clear删除断点
+ 后面视频会讲 pycharm 调试

## 进程

+ 时间片轮转、优先级调度，实现多任务切换执行
+ 并发：任务数 > 核数    并行：任务数 < 核数
+ 写完之后代码叫程序，运行着整个的环境的叫进程
+ windows 没有 fork 调用
+ os.fork() 
+ 创建多任务（进程）
```python
'''
主（父）进程、子进程。
'''
import os
import time

ret = os.fork()
if ret==0:
    while True:
        print('-----1------')
else:
    while True:
        print('-----2------')
```
+ 子进程永远返回 0. 父进程大于 0（即子进程的id）
+ os.getpid() 获取进程id值
+ os.getppid() 获取父进程的id值
+ 进程和进程之间数据不共享
+ n个fork() 。2^n 个进程
+ multiprocessing 模块，跨平台的多进程模块.特点是只有子进程都结束了，主进程才会结束
```python
from multiprocessing import Process
import time

def test():
    while True:
        print('--test--')
        time.sleep(1)

p = Process(target=test)
p.start() #让这个进程开始执行 target 值函数的代码

while True:
    print('--main--')
    time.sleep(1)
```
+ 进程池pool。池的作用一般就是缓存
```python
from multiprocessing import Pool
import os
import random
import time

def worker(num):
    for i in range(5):
        print("===pid=%d==num=%d="%(os.getpid(), num))
        time.sleep(1)

#3表示 进程池中对多有3个进程一起执行
pool = Pool(3)

for i in range(10):
    print("---%d---"%i)
    pool.apply(worker, (i,))#堵塞的方式


pool.close()#关闭进程池，相当于　不能够再次添加新任务了
pool.join()#主进程　创建／添加　任务后，主进程　默认不会等待进程池中的任务执行完后才结束
            #而是　当主进程的任务做完之后　立马结束，，，如果这个地方没join,会导致
            #进程池中的任务不会执行
```
+ 创建进程的三种方式

+ 进程间通信：


## 线程（thread）
+ 用线程实现多任务
+ python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用
+ 指到哪里就执行到哪里，这个箭头就是线程，线程是进程里真正执行代码的东西
+ 即使主线程已经执行结束，也要等到子线程执行完了才会继续往下执行（结束）
```python
from threading import Thread
import time

def test():
    print('---test---')
    time.sleep(1)
    
for i in range(5):
    t = Thread(target=test)
    t.start()
```
+ 如果多个线程执行的都是同一个函数的话，各自之间不会有影响，各是各的
+ 使用 Thread 子类完成创建多线程
```python
import threading
import time

class MyThread(threading.Thread):
    def run(self):
        for i in range(3):
            time.sleep(1)
            msg = "i'm" + self.name # name属性保存的是当前线程的名字
            print(msg)
            
if __name__ == '__main__':
    t = MyThread()
    t.start()
```
+ 线程的执行顺序是不定的
+ 对于多线程，全局变量是共享的。由此可以实现多线程之间的数据共享，但也会造成多线程之间对全局变量的混乱（即线程非安全）
+ 进程和线程的区别：线程是进程的一个实体,是CPU调度和分派的基本单位。一个程序至少有一个进程,一个进程至少有一个线程
+ 互斥锁.通常用于对全局变量进行修改的情况。注意死锁
```python
#创建锁
mutex = threading.Lock()
#锁定
mutex.acquire()
#释放
mutex.release()
```
+ 同步：可以使用互斥锁完成多个任务，有序的进程工作，这就是线程的同步。有规律的工作
+ 生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题
+ Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue
+ 异步
```python
from multiprocessing import Pool
import time
import os

def test():
    print("---进程池中的进程---pid=%d,ppid=%d--"%(os.getpid(),os.getppid()))
    for i in range(3):
        print("----%d---"%i)
        time.sleep(1)
    return "hahah"

def test2(args):
    print("---callback func--pid=%d"%os.getpid())
    print("---callback func--args=%s"%args)

pool = Pool(3) # 进程池
pool.apply_async(func=test,callback=test2) # 回调。test做完后做callback。test返回的值主进程返回给了callback做参数

time.sleep(5)

print("----主进程-pid=%d----"%os.getpid())
```
+ 异步的理解：我正做着事，另一件事我不确定什么时候做，需要我做我就停下手头的事去做。该干啥干啥
+ python多线程是假多线程。在python中，多进程的效率要远远大于多线程，多核明显。
+ GIL。C语言

## 网络编程
### socket
+ 计算机的通信协议 TCP/IP 协议。规范不同网络设备的数据传递
+ 协议族，一堆协议的总称
+ 链路层 -> 网络层 -> 传输层 -> 应用层
+ 物理层 -> 数据链路层 -> 网络层 -> 传输层 -> 会话层 -> 表示层 -> 应用层 [记忆](http://www.slyar.com/blog/all-people-seem-to-need-data-process.html)
+ 理论是7层，实际开发是4层
+ 交换机组成局域网
+ 为了区分数据给哪个进程，端口。ip地址制定电脑，端口标记进程，端口就是一个值
+ 为什么不用 pid?自己的pid知道，别人的不知道啊。对方必须是唯一确定的值
+ 端口号。0-65535.知名端口（0-1023）.后面的是动态端口
+ ip地址的作用：ip地址是网络上标记电脑用的
+ ip地址包括两部分：网络地址和主机地址
+ socket。多台主机间的进程通信用 socket（套接字）。套接字是一种机制，是进程间通信的一种方式
+ 创建 socket：`socket.socket(AddressFamily, Type)`
    + Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET
    + Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）
```python
from socket import *

#1. 创建套接字
udpSocket = socket(AF_INET, SOCK_DGRAM)

#2. 准备接收方的地址
sendAddr = ('192.168.1.103', 8080)

#3. 从键盘获取数据
sendData = raw_input("请输入要发送的数据:")

#4. 发送数据到指定的电脑上
udpSocket.sendto(sendData, sendAddr)

#5. 关闭套接字
udpSocket.close()
```
+ udp绑定信息。如果需要做成一个服务器端程序，udp的端口需要绑定
```python
from socket import *

#1. 创建套接字
udpSocket = socket(AF_INET, SOCK_DGRAM)

#2. 绑定本地的相关信息，如果一个网络程序不绑定，则系统会随机分配
bindAddr = ('', 7788) # ip地址和端口号，ip一般不用写，表示本机的任何一个ip.可能本机多个网卡，ip都不一样。当然也可以绑定一个固定的自己的ip。绑别人的会失败
udpSocket.bind(bindAddr)

#3. 等待(关键是等待)接收对方发送的数据
recvData = udpSocket.recvfrom(1024) # 1024表示本次接收的最大字节数 recvData[0] recvData[1]

#4. 显示接收到的数据
print recvData

#5. 关闭套接字
udpSocket.close()
```
+ 发送方不需要绑，接收方要绑定。发送方需要知道目标ip和端口。接收方需要绑定自己接收的端口
+ 套接字可收可发，且是可以同时进行的。UDP/TCP都是全双工的
+ python3中.sendto需要字节类型的对象。写成`udpSocket.sendto(sendData.encode('utf-8'), sendAddr)`.发送的编码成了utf-8，接受方也要按照此解码
+ 发送方组包，接收方解包

+ qq登录实际上是给服务器发送了消息，记录了ip和端口
+ 一个线程解决发，一个解决收
```python
# 全双工。两个线程

from socket import *
from threading import Thread


# 收数据，然后打印
def recvData():
    while True:
        recvInfo = udpSocket.recvform(1024)
        print('>>{}: {}'.format(str(recvInfo[1]), recvInfo[0]))


# 检测键盘，发数据
def sendData():
    while True:
        sendInfo = input('<<')
        udpSocket.sendto(sendInfo.encode('utf-8'), (destIp, destPort))


udpSocket = None
destIp = ''
destPort = 0


def main():

    global udpSocket
    global destIp
    global destPort

    udpSocket = socket(AF_INET, SOCK_DGRAM)
    udpSocket.bind(('', 4567))

    tr = Thread(target=recvData)
    ts = Thread(target=sendData)

    tr.start()
    ts.start()

    tr.join() # 主线程要等子线程结束
    ts.join() # 主线程要等子线程结束
    # 多线程多join的情况下，依次执行各线程的join方法，前头一个结束了才能执行后面一个。上面的实际不会结束的


if __name__ == '__main__':
    main()
```

### wireshark
+ TFTP下载器
+ c/s架构 client/server 客户端/服务器
+ b/s架构 browser/server 浏览器/服务器
+ 下载：创建一个空文件 -> 向里面写数据 -> 关闭

### 网络通信过程
+ 只有 UDP 才有广播，TCP没有
+ 通信方式一般认为就两种，TCP 和 UDP
+ tcp：传输控制协议 [模型](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/html%E7%89%88/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%85%A8%E9%83%A8%E8%AF%BE%E4%BB%B6/02day/section.5.html)
    + 稳定（一定能收到）
    + 相对于udp，适当慢一些（因为它通信前要建立连接）
    + web服务器都是用的tcp
+ udp：用户数据包协议
    + 不稳定
    + 比tcp适当快一些
+ 监听套接字和新的套接字
```python
# tcp 服务器的流程
    # socket创建一个套接字
    # bind绑定ip和port
    # listen使套接字变为可以被动链接
    # accept等待客户端的链接
    # recv/send接收发送数据

from socket import *

serverSocket = socket(AF_INET, SOCK_STREAM)

serverSocket.bind(("", 8899))

serverSocket.listen(5) # 由主动套接字变被动套接字。使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了

clientSocket, clientInfo = serverSocket.accept()
# clientSocket 表示新的客户端套接字，它才是接下来实际作用的。产生一个新的套接字专门为这个客户端服务
# serverSocket 是监听套接字，只负责沟通监听、建立连接。专门等待其他新客户端的链接
# clientInfo 表示这个新的客户端的 ip 和 port
# 类比电话。一个是专门用来响的，一个是专门用来说话的

recvData = clientSocket.recv(1024)

print("{}:{}".format(str(clientInfo), recvData))

clientSocket.close()
serverSocket.close()
```

```python
# tcp客户端流程
# 创建socket
# connect()
from socket import *

# 创建socket
tcpClientSocket = socket(AF_INET, SOCK_STREAM)

# 链接服务器
serAddr = ('192.168.1.102', 7788)
tcpClientSocket.connect(serAddr)

# 提示用户输入数据
sendData = raw_input("请输入要发送的数据：")

tcpClientSocket.send(sendData)

# 接收对方发送过来的数据，最大接收1024个字节
recvData = tcpClientSocket.recv(1024)
print '接收到的数据为:',recvData

# 关闭套接字
tcpClientSocket.close()

```
+ 在tcp中用 send/recv, 在udp中用 sendto/recvfrom ，因为在tcp中连接一次就可源源不断的发送和接收
+ tcp客户端已经连接好了服务器，所以在以后的数据发送中，不需要填写对方的ip和port。
+ udp在发送数据的时候，因为没有之前的连接，所以每次发送的时候都需要填写对方的ip和port
```python
# 这个是单任务的服务器，参考一下即可
from socket import *

# 创建socket
tcpSerSocket = socket(AF_INET, SOCK_STREAM)

# 绑定本地信息
address = ('', 7788)
tcpSerSocket.bind(address)

# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了
tcpSerSocket.listen(5)

while True:

    # 如果有新的客户端来链接服务器，那么就产生一个信心的套接字专门为这个客户端服务器
    # newSocket用来为这个客户端服务
    # tcpSerSocket就可以省下来专门等待其他新客户端的链接
    newSocket, clientAddr = tcpSerSocket.accept()

    while True:

        # 接收对方发送过来的数据，最大接收1024个字节
        recvData = newSocket.recv(1024)

        # 如果接收的数据的长度为0，则意味着客户端关闭了链接
        # 如果接收的客户端的数据长度为0，那么意味着款客户端通过调用 close 下线
        if len(recvData)>0:
            print 'recv:',recvData
        else:
            break

        # 发送一些数据到客户端
        sendData = raw_input("send:")
        newSocket.send(sendData)

    # 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接
    newSocket.close()

# 关闭监听套接字，只要这个套接字关闭了，就意味着整个程序不能再接收任何新的客户端的连接
tcpSerSocket.close()
```

```python
# 并发的，多任务服务器
# 基本思路process多进程

def clientDeal(cSocket):
    while True:
        cSocket.recv(xxx)
        cSocket.send(xx)

s = socket()
s.bind()
s.listen()
while True:
    cSocket, cInfo = s.accept()
    p = Process(target=clientDeal, args=(cSocket,))
    p.start()

```
+ 网络掩码。通过网络掩码知道ip地址的网络号。网络号=ip地址 与 网络掩码 按位与操作。网络号相同才是同一网段，才能通信
+ 集线器：用来连接多台电脑的设备（两台以上），几乎已被淘汰。所有数据包都是广播发送，容易拥堵
+ 交换机：用来连接多台电脑的设备（两台以上）。有一个学习功能，学习之后就是单播
+ 两台电脑能通信的前提是在同一个网段里
+ MAC地址：网卡的序列号
+ 路由器：又被称为网关设备（gateway），用于连接多个逻辑上分开的网络（网络号不一样），即连接不同的网段，使能通信
+ 跨网之间不允许直接通信。路由器至少有两个网卡，这样才能通信
+ 有了ip为什么要mac地址：mac地址在两个设备之间通信时在变化，而ip地址在通信过程中都不会变化
+ mac地址是手拉手传递数据用的，ip是用来标记最后把数据给谁
    + ip：标记逻辑上的地址
    + mac：标记实际转发数据时的地址
    + netmask（网络掩码）：和ip地址一起来确定网络号
    + 默认网关：发送的ip不在同一个网段内，那么会把这个数据转发给默认网关（转给下一个路由器）
+ 在浏览器中打开 baidu.com 发生了什么：
    + 先要解析出 baidu.com 对应的 ip 地址
        + 先要知道默认网关的 mac
            + 使用 arp 获取默认网关的 mac
        + 组织数据发送给默认网关（ip还是dns服务器的ip，但是mac地址是默认网关的mac地址）
        + 默认网关拥有转发数据的能力，把数据转发给路由器
        + 路由器根据自己的路由协议，来选择一个合适的较快的路径转发数据给目的网关
        + 目的网关（dns 服务器所在的网关），把数据转发给 dns 服务器
        + dns服务器查询解析出 baidu.com 对应ip地址，并把它原路返回给请求这个域名的client
    + 得到 baidu.com 对应的 ip 地址后，发送 tcp 的 3 次握手，进行连接
    + 使用 http 协议发送请求数据给 web 服务器
    + web 服务器收到数据请求后，通过查询服务器得到相应结果，原路返回给浏览器
    + 浏览器收到数据后，渲染显示
    + 浏览器关闭 tcp 连接，即 4 次挥手
+ 在tcp中，如果有一方收到了对方的数据，一定会发送ack确认包给发送方。而在udp中，没有这个过程，因此导致了tcp稳定，而udp不稳定
+ dns是UDP协议
+ dhcp是给机器分配ip地址的
+ ![tcp比udp稳定的原因.png](http://upload-images.jianshu.io/upload_images/6434703-bb7b542cf38d1135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
+ ![tcp三次握手.png](http://upload-images.jianshu.io/upload_images/6434703-e6cc5719ff9d4123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
+ tcp三次握手    ACK(确认包)   SYN(标记TCP包的作用为请求)
    + 客户端通过向服务器发送一个 SYN 来创建一个主动打开。客户端把这段连接的序号设定为随机数 A
    + 服务器为一个合法的 SYN 回送一个 SYN/ACK . ACK 的确认码应该是 A+1。SYN/ACK 包本身又有一个随机序号
    + 最后，客户端再发送一个 ACK.当服务端受到这个 ACK 的时候，就完成了三次握手，并进入了连接创建状态。
    + 一个是 A+1,一个是 B+1
+ 四次挥手：
    + A 调用 close(),发送一个包给 B
    + B 收到后，回 ACK 表示知道
    + B 调用 close(),发送一个包给 A，表示我也关了
    + A 收到回一个 ACK
+ 长连接：在线看电影 握手-多次发送发送发送-挥手
+ 短连接：浏览器，握手-发送-挥手-握手-发送-挥手 数据量少用短连接
+ tcp的十种状态
+ ping 中的 TTL：一个数据包在网络中经过的路由器的最大值。每经过一个，减一
+ MSL：最长存活时间
+ 127.0.0.1 本地
+ 在linux中，listen中参数的值写几都无所谓，因为它是自动决定的
+ 常见的网络攻击：
    + DDOS：SYN洪水
    + DNS攻击：DNS用的协议是 UDP，到假的域名服务器解析
    + DNS欺骗：DNS 欺骗简单来说就是用一个假的 DNS 应答来欺骗用户计算机。让其相信这个假的DNS应答包，并且抛弃真正的 DNS 应答
    + arp 攻击
+ 调制解调器：调制器把数字信号转换成模拟信号在电话网上传送，解调器把接收到的模拟信号还原成数字信号传送给电子计算机
+ NAT网络地址转换器(玩出花样来了，既是路由器，又是交换机)
+ 并行：核数大于任务数    并发：任务数大于核数

+ 多进程服务器
```python
from socket import *
from multiprocessing import *
from time import sleep

# 处理客户端的请求并为其服务
def dealWithClient(newSocket,destAddr):
    while True:
        recvData = newSocket.recv(1024)
        if len(recvData)>0:
            print('recv[%s]:%s'%(str(destAddr), recvData))
        else:
            print('[%s]客户端已经关闭'%str(destAddr))
            break

    newSocket.close()


def main():

    serSocket = socket(AF_INET, SOCK_STREAM)
    serSocket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # 操作系统会在服务器socket被关闭或服务器进程终止后马上释放该服务器的端口，否则操作系统会保留几分钟该端口
    localAddr = ('', 7788)
    serSocket.bind(localAddr)
    serSocket.listen(5)

    try:
        while True:
            print('-----主进程，，等待新客户端的到来------')
            newSocket,destAddr = serSocket.accept()

            print('-----主进程，，接下来创建一个新的进程负责数据处理[%s]-----'%str(destAddr))
            client = Process(target=dealWithClient, args=(newSocket,destAddr))
            client.start()

            #因为已经向子进程中copy了一份（引用），并且父进程中这个套接字也没有用处了
            #所以关闭
            newSocket.close()
    finally:
        #当为所有的客户端服务完之后再进行关闭，表示不再接收新的客户端的链接
        serSocket.close()

if __name__ == '__main__':
    main()
```
+ 进程可以关，因为进程独立，可以理解为完全复制。线程不能，共享数据，关了子线程还在用，会崩溃
+ 多线程服务器
```python
#coding=utf-8
from socket import *
from threading import Thread
from time import sleep

# 处理客户端的请求并执行事情
def dealWithClient(newSocket,destAddr):
    while True:
        recvData = newSocket.recv(1024)
        if len(recvData)>0:
            print('recv[%s]:%s'%(str(destAddr), recvData))
        else:
            print('[%s]客户端已经关闭'%str(destAddr))
            break

    newSocket.close()


def main():

    serSocket = socket(AF_INET, SOCK_STREAM)
    serSocket.setsockopt(SOL_SOCKET, SO_REUSEADDR  , 1)
    localAddr = ('', 7788)
    serSocket.bind(localAddr)
    serSocket.listen(5)

    try:
        while True:
            print('-----主进程，，等待新客户端的到来------')
            newSocket,destAddr = serSocket.accept()

            print('-----主进程，，接下来创建一个新的线程负责数据处理[%s]-----'%str(destAddr))
            client = Thread(target=dealWithClient, args=(newSocket,destAddr))
            client.start()

            #因为线程中共享这个套接字，如果关闭了会导致这个套接字不可用，
            #但是此时在线程中这个套接字可能还在收数据，因此不能关闭
            #newSocket.close()
    finally:
        serSocket.close()

if __name__ == '__main__':
    main()
```
+ 多进程和多线程比较的话，是多线程占优，因为多进程占用的资源多

+ 协程在线程里面
+ 计算密集型用多进程  IO密集型用多线程和协程
+ 协程，安装 greenlet 模块，需要人工切
+ 协程，安装 gevent。gevent服务器


## 正则表达式
+ dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表
+ 在Python中需要通过正则表达式对字符串进行匹配的时候，可以使用一个模块，名字为re
```python
# 导入re模块
    import re

    # 使用match方法进行匹配操作.若匹配返回匹配对象，否则 None
    result = re.match(正则表达式,要匹配的字符串)

    # 如果上一步匹配到数据的话，可以使用group方法来提取数据
    # 匹配对象有 group() 方法，用来返回字符串的匹配部分。先匹配再分组
    result.group()
```
+ re.match() 能够匹配出以xxx开头的字符串
+ ![11.PNG](http://upload-images.jianshu.io/upload_images/6434703-87eb77d97897927e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
+ 字符记忆说明：
    + . 任意一个字符，\n除外
    + [] 匹配 [] 列举的字符  匹配方括号中的一个  [^]->对方括号中所有取反
    + \d 匹配数字 digit                 大写相反
    + \s 匹配空白 space 就是空格和 tab \n 凡是不显示的都是空白字符   大写相反
    + \w 匹配字母、数字、下划线 word     大写相反
    + [a-z5-9] - 代表的是范围值
+ 表示数量的：
+ ![222.PNG](http://upload-images.jianshu.io/upload_images/6434703-33768077fdc0fbff.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
+ 原生字符串：Python中字符串前面加上 r 表示原生字符串
    + 正则表达式里使用"\"作为转义字符
    + 用了原生字符串只需要专注于匹配原生字符串里的反斜杠就好了，原生字符串一个 \ ，正则就 \\
    + re.match(r'\\nabc', s)
+ 写正则时，通常前面都要加一个 r ，可以避免转义出现问题
+ ![333.PNG](http://upload-images.jianshu.io/upload_images/6434703-e599410324760415.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
+ [正则速查表](http://www.jb51.net/shouce/jquery/regexp.html)
+ 匹配分组
+ ![555.PNG](http://upload-images.jianshu.io/upload_images/6434703-83375f694e381eff.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
+ 三个引号是真是存在的数据，并不能简单的就只理解为注释
+ Python里数量词默认是贪婪的，总是尝试匹配尽可能多的字符。在"*","?","+","{m,n}"后面加上？，使贪婪变成非贪婪
+ search（扫描整个字符串并返回第一个成功的匹配）re.search(正则, string)
+ findall （在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表） re.findall(正则，string)
+ sub（用于替换字符串中的匹配项）re.sub(正则, 新的字符串-可为函数, string)


## Web服务器
+ 层级复习：（应传网链）
    + 应用层：解决要传递什么数据
    + 传输层：解决如何传输数据 udp tcp，可以理解为快递公司
    + 网络层：ip协议，理解为地理坐标位置
    + 链路层：具体的传输工具
    + socket用来解决传输层以下的东西
    + 应用层的协议，应用场景不一样，用的协议也不一样。重点是http协议
+ HTTP请求方式：
    + GET 获取数据
    + POST 修改数据
    + PUT 保存数据
    + DELETE 删除
    + OPTION 询问服务器的某种服务支持特性
    + HEAD 返回报文头
+ GET 后跟的是 URL 的路径。http协议的1.1版本
+ 请求头：类似于python中字典格式的，告诉服务器的信息
+ 如果是 POST，请求还包括一个 body，包含用户数据
+ 一个 HTTP 请求只处理一个资源，理解为tcp协议中的短连接，每个链接只获取一个资源，如需要多个就需要建立多个链接
+ GET 网址后加问号传数据，通过get方式放到url中。问号后的叫 查询字符串（query string）
+ 每个Header一行一个，换行符是\r\n
+ 当遇到连续两个\r\n时，Header部分结束，后面的数据全部是Body
+ GET 只有 query，POST 才有 body
+ tcp服务端，显示固定页面
```python
import socket

from multiprocessing import Process


def handle_client_socket(client_socket):
    request_data = client_socket.recv(1024)
    print(request_data)
    response_start_line= 'HTTP/1.1 200 OK\r\n'
    response_headers = 'Server: csurong server\r\n'
    response_body = 'Hello csurong'
    response = response_start_line + response_headers + '\r\n' + response_body
    print(type(response.encode('utf-8')))
    client_socket.send(response.encode('utf-8'))
    client_socket.close()


if __name__ == '__main__':
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(('', 8000))
    server_socket.listen(5)

    while True:
        client_socket, client_address = server_socket.accept()
        handle_client_process = Process(target=handle_client_socket, args=(client_socket,))
        handle_client_process.start()
        client_socket.close()
```
+ 使用类完成tcp服务器显示需要的页面
```python
# coding:utf-8

import socket
import re

from multiprocessing import Process

# 设置静态文件根目录
HTML_ROOT_DIR = "./html"


class HTTPServer(object):
    """"""
    def __init__(self):
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    def start(self):
        self.server_socket.listen(128)
        while True:
            client_socket, client_address = self.server_socket.accept()
            # print("[%s, %s]用户连接上了" % (client_address[0],client_address[1]))
            print("[%s, %s]用户连接上了" % client_address)
            handle_client_process = Process(target=self.handle_client, args=(client_socket,))
            handle_client_process.start()
            client_socket.close()

    def handle_client(self, client_socket):
        """处理客户端请求"""
        # 获取客户端请求数据
        request_data = client_socket.recv(1024)
        print("request data:", request_data)
        request_lines = request_data.splitlines()
        for line in request_lines:
            print(line)

        # 解析请求报文
        # 'GET / HTTP/1.1'
        request_start_line = request_lines[0]
        # 提取用户请求的文件名
        print("*" * 10)
        print(request_start_line.decode("utf-8"))
        file_name = re.match(r"\w+ +(/[^ ]*) ", request_start_line.decode("utf-8")).group(1)

        if "/" == file_name:
            file_name = "/index.html"

        # 打开文件，读取内容
        try:
            file = open(HTML_ROOT_DIR + file_name, "rb")
        except IOError:
            response_start_line = "HTTP/1.1 404 Not Found\r\n"
            response_headers = "Server: My server\r\n"
            response_body = "The file is not found!"
        else:
            file_data = file.read()
            file.close()

            # 构造响应数据
            response_start_line = "HTTP/1.1 200 OK\r\n"
            response_headers = "Server: My server\r\n"
            response_body = file_data.decode("utf-8")

        response = response_start_line + response_headers + "\r\n" + response_body
        print("response data:", response)

        # 向客户端返回响应数据
        client_socket.send(bytes(response, "utf-8"))

        # 关闭客户端连接
        client_socket.close()

    def bind(self, port):
        self.server_socket.bind(("", port))


def main():
    http_server = HTTPServer()
    # http_server.set_port
    http_server.bind(8000)
    http_server.start()


if __name__ == "__main__":
    main()

```
+ 动态加载模块：m = __import__(file_name[1:-3]) m.application(),返回的应该是响应体，即body部分
###  定义WSGI接口：
+ WSGI:Web服务器网关接口，是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口
WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello World!”：
```python
def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')]) # 这个函数是 web 服务器提供的，两个参数，状态码和协议头。服务器提供部分的协议头
    return 'Hello World!'
```
上面的application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：
environ：一个包含所有HTTP请求信息的dict对象，把请求报文都放字典里了；
start_response：一个发送HTTP响应的函数。
整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，把底层web服务器解析部分和应用程序逻辑部分进行了分离，这样开发者就可以专心做一个领域了
不过，等等，这个application()函数怎么调用？如果我们自己调用，两个参数environ和start_response我们没法提供，返回的str也没法发给浏览器。
所以application()函数必须由WSGI服务器来调用
+ application（）函数返回的是响应的 body 部分，但由于它的执行状态会影响到 状态码 之类的响应头，所以内部有在外部服务器中定义的设置响应头的函数。是用这个函数得到响应头数据的，服务器对象函数，直接就组装成了 self.response_headers，因为是对象方法，所以直接就作为对象self属性了。handle_client 中的response也有self。
+ web server + web framework 实际 server 是不需要自己写的，要处理的就是 framework 以及 视图函数


+ 字典用 dic.get(key) 没有会返回 None，不会报错。dic[key] 没有会报错

## git
+ 普通命令：
    + git init 本地初始化 git 仓库，如果是远程 clone 下来的就不用，会自带
    + git status
    + git add
    + git commit -m '提交信息'
+ 分支：
    + git branch            查看分支
    + git branch test       新建分支
    + git checkout test     切换分支
    + git checkout -b test  新建切换一条龙
    + 合并：
        + 切换到 master  分支
        + git merge test 把test合并过来
    + git branch -d test    删除分支
    + git branch -D test    强制删除分支
    + 远程分支：
        + git branch -r             查看远程分支列表
        + git push origin :xxx      删除远程分支
        + git checkout xdevelopx origin/xdevelopx 将远程的 xdevelopx 分支迁到本地
+ 标签：
    + git tag v1.0          打标签
    + git tag               查看历史 tag 记录
    + git checkout v1.0     切换到 v1.0 时的代码状态
+ 公钥私钥：
    + .pub 的即是公钥，公共嘛
    + ssh -T git@github.com     测试是否与 github 连接成功
    + 在提交代码之前先要设置下自己的用户名与邮箱，这些信息会出现在所有的 commit 记录里
        + git config --global user.name "csurong"
        + git config --global user.email "csurong1@gmail.com"
        + --global 是全局配置。若特定项目用特定邮箱，在此项目中将 --global 去掉重新配置即可
        + 提交邮箱与 github 上的邮箱一致才会有绿色提交记录显示
    + git 的一些配置：
        + git config --global color.ui true             给 git 着色
        + git config --global core.quotepath false      设置显示中文文件名
        + git config -l                                  git 的一些配置
+ 同步：
    + git clone git@xxx                 克隆github上的项目，默认已经完成初始化和关联
    + git remote add origin git@xxx     本地已有的情况下与远程仓库关联。公认的只有一个远程仓库时名字就是 origin
    + git push
        + git push origin master            推送到远程仓库中的主分支
        + git push origin develop           推送到远程仓库中的名为 develop 分支
+ 操作：
    + git diff
        + git diff                          直接输入，比较当前和之前已commit的区别
        + git diff <$id1> <$id2>            比较两次提交之间的差异
        + git diff <branch1>..<branch2>     在两个分支之间比较
        + git diff --staged                 比较暂存区(已add过的)和版本库差异
    + git checkout
        + git checkout 分支/tag/commit
        + git checkout xx.xx 还原已修改但还没进暂存区的文件（没有git add 过）
    + git stash (避免垃圾commit)
        + git stash         把当前分支没有 commit 的代码暂存起来
        + git stash pop     还原代码，删除最近这条stash记录  （git stash apply; git stash drop）
        + git stash list    查看所有stash记录
        + git stash clear   清空所有stash记录
    + 两个分支发生冲突后，会提示冲突的地方，需手动解决后，再commit
+ 在项目的根目录里添加一个 README.md 文件，使用 markdown 语法，GitHub 自动会对该文件进行渲染

## flask
+ 虚拟环境：
    + python -m venv <name> 创建虚拟环境
    + Scripts\activate.bat  激活虚拟环境
    + deactivate            退出虚拟环境
    + pip modual_name       安装包
    + pip list              查看已安装包
    + 使用pycharm切换成虚拟环境目录
    + 新建项目地址最好选择和虚拟环境同级的文件夹。这个文件夹的名字就是项目的名字
    + 新建项目。flask使用已有的虚拟环境，解析器选择虚拟环境scripts文件夹中的 python.exe
+ app.run(debug=True) 调试模式，服务器不用关，直接刷新浏览器
+ HTML 中 url_for 的使用
    + <a href="{{ url_for('.about') }}">about</a> html中可以直接用，flask中不需要导入 url_for().这个‘.’代表python中的相对路径
    + <link rel="stylesheet" href="{{ url_for('static', filename='site.css') }}">
+ pycharm 自动格式化快捷键：Alt + CTRL + L
+ 定义动态路由：@app.route('/user/<username>') 转换器：int float path @app.route('/user/<int:user_id>') 也可以自定义URL转换器，此处不细究
+ 导出环境安装模块的信息：pip freeze > requirements.txt    安装环境依赖包：pip install -r requirements.txt
+ 由于 flask 0.11 中自带了命令行的功能 ，因此无需再使用 flask-sript 插件
    + set FLASK_APP = xxx.py
    + set FLASK_DEBUG = 1
    + flask run
    + 只有在 windows 中才使用 set
+ 自定义过滤器使 markdown >>>> HTML
```python
# 在模版中只要 {{ body|md|safe }} 即可转换
@app.template_filter('md')
def markdown_to_html(txt):
    from markdown import markdown
    return markdown(txt)
```
+ 上下文处理器：
    + 模版可以接收服务端的 变量、过滤器、方法
    + 这意味着在 {{ }} 中调用服务端的函数
    + 操作：通过上下文处理器将方法注册到模版中。上下文处理器在模版渲染之前运行。
    + 上下文处理器返回字典，并将键值传给所有模版。使用键即可。只要字典返回某个函数的函数名，就可以在模版使用python函数了
    + 使用装饰器 @app.context_processor


## 前端
### HTML
+ <meta charset='UTF-8>
+ <h1> <p> <br> <div> <span> <ol> <ul> <li> <img src='' alt=''> <a href=''>(# 表示链接到页面顶部, #id也可跳到相应位置)
+ <iframe src='' srcolling='no'> src属性来定义另一个html文件的引用地址 <iframe>标签会创建包含另外一个html文件的内联框架（即行内框架）。令a标签的target值与iframe的name值相同，即可实现点击a，iframe改变
+ html中多个空格只显示一个空格，要想显示要用字符实体：&nbsp。< >也要用字符实体
+ 相对路径：
    + “ ./ ” 表示当前文件所在目录下，比如：“./pic.jpg” 表示当前目录下的pic.jpg的图片，这个使用时可以省略
    + “ ../ ” 表示当前文件所在目录下的上一级目录，比如：“../images/pic.jpg” 表示当前目录下的上一级目录下的images文件夹中的pic.jpg的图片
+ 表单：
    + <form action="http://www..." method="get">
    + <label for=''> label绑定表单控件 一是包围控件元素，二是 for 值与控件 id 值相等
    + input
        + text
        + radio 单选 name相同value不同
        + checkbox 多选 同上
        + file 上传文件
        + submit 提交
        + reset 重置
    + textarea 多行输入
    + select option1 option2 下拉列表
+ html里属性是不给单位的
+ [表格及其常用属性](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/%E5%89%8D%E7%AB%AF/01/mds/section08.html)

### CSS
+ CSS 引入：<link rel="stylesheet" type="text/css" href="css/main.css"> style标签放html头部可以提高网页性能
+ 文本：
```
color:red;

font-size:12px;

font-family:'微软雅黑';

font-style:'normal'; 设置不倾斜， font-style:'italic';设置文字倾斜

font-weight:bold; 设置加粗 font-weight:normal 设置不加粗

font：是否加粗 字号/行高 字体；如： font:normal 12px/36px '微软雅黑';

line-height 设置文字的行高，如：line-height:24px;

text-decoration 设置文字的下划线，如：text-decoration:none; 将文字下划线去掉

text-indent 设置文字首行缩进，如：text-indent:24px; 设置文字首行缩进24px。text-indent是content中的，width内部的

text-align 设置文字水平对齐方式，如text-align:center 设置文字水平居中

```
+ 颜色：red rgb(0,0,0) #0000FF
+ 选择器：
    + 标签选择器 *{margin:0;padding:0}
    + id选择器
    + 类选择器 应用最广泛
    + 层级选择器 一层层的 父子子
    + 组选择器，用逗号隔开，应用相同样式
    + 伪类 .class1:hover   .class1:before   .class1:after （before、after可以通过样式在元素中插入内容 content：‘内容’）
    + p.cla1  class=cla1 的 p 元素
+ 元素分类：
    + 块元素
        + 永远占据一行
    + 内联元素
        + 不支持设置宽、高、上下padding、上下margin
        + 宽高由内容决定
        + 子元素是内联元素，父元素可以用text-align属性设置子元素水平对齐方式，用line-height属性值设置垂直对齐方式
        + 代码换行，盒子间会产生间距
        + 解决内联元素间隙的方法
            1 去掉内联元素之间的换行
            2 将内联元素的父级设置font-size为0，内联元素自身再设置font-size
    + 内联块元素
        + 支持全部样式
        + 会有间隙。解决方案同上
        + 子元素是内联块元素，父元素可以用text-align属性设置子元素水平对齐方式，用line-height属性值设置子元素垂直对齐方式
    + display： block inline inline-block
    + inline 和 inline-block 中间都会有间隙，但是浮动之后就不会有
+ 盒子模型：
    + margin相关技巧
        1. 设置元素水平居中： margin:x auto;
        2. margin负值让元素位移及边框合并
        3. 垂直的 margin 会合并，取大的。只发生于块元素，inline-block并不适用
    + margin-top塌陷：在两个盒子嵌套时候，内部的盒子设置的margin-top会加到外边的盒子上，导致内部的盒子margin-top设置失败，解决方法如下：
        1. 外部盒子设置一个边框
        2. 外部盒子设置 overflow:hidden
        3. 使用伪元素类：（这是最常用的）
```css
.clearfix:before{
    content: '';
    display:table;
}
```
+ overflow 设置父元素显示溢出子元素的方式。hidden可以清除浮动
+ 浮动：
    + 浮动的元素会向左或向右浮动，碰到父元素边界、浮动元素、未浮动的元素才停下来
    + 相邻浮动的块元素可以并在一行，超出父级宽度就换行
    + 浮动让行内元素或块元素自动转化为行内块元素
    + 文字绕图。脱离文档流，位子会占，但后面文字还是会避开
        + 浮动元素后面没有浮动的元素会占据浮动元素的位置，没有浮动的元素内的文字会避开浮动的元素，形成文字饶图的效果。
        + 浮动脱离了文档流，后面的元素会占据它的位置，但为了自己不被遮住，文字还是会避开它
        + 浮动和不浮动放一块，一般仅用于文字绕图
    + 清除浮动，撑开父元素：
        + 浮动的子元素没法撑开父元素（即自动决定父元素的高），因为脱离文档流了，认为子元素不存在。此时需要清除浮动
        + 父级上增加属性overflow：hidden
        + 在最后一个子元素的后面加一个空的div，给它样式属性 clear:both（不推荐）
        + 使用成熟的清浮动样式类，clearfix（推荐）
```css
.clearfix:after {
    content: "";
    display: table;
    clear: both;
}
```
+ 解决 margin 塌陷和清除浮动的统一写法：
```css
.clearfix:before, .clearfix:after {
    content: "";
    display: table;
}

.clearfix:after {
    clear: both;
}

.clearfix {
    zoom: 1; 给IE的
}
```
+ 定位：定位元素是浮动的正常的文档流之上的，可以用z-index属性来设置元素的层级
    + relative 占据的文档流的位置不变，元素本身相对文档流的位置进行偏移。                         相对于自身文档流
    + absolute 不占文档流，漂浮在文档流的上方，相对于上一个设置了position的父级元素来进行定位。     相对于父position。一般都是将父级设成relative，这样既不影响也能做参照
    + fixed    不占据文档流，漂浮在文档流的上方，相对于浏览器窗口进行定位                          相对于视图窗口
    + relative相对中庸，因此保留文档流，这叫稳中求进。剩下的都是走极端的。
    + 典型用法：固定在顶部的菜单、底部按钮、侧边工具栏、弹框
+ background
    + background:blue url(bg.jpg) repeat-x
    + background:blue url(bg.jpg) no-repeat right center
    + background-color；background-image；background-repeat；background-position
+ 特征布局的一些实例讲解，很好的参考。见CSS视频2的最后两个，ps的第一个


## JavaScript
+ V8引擎，js加载很快
+ ajax 无刷新交互
+ 实际用还是用 jquery
+ js做动画的原理其实就是改变 css
+ js嵌入方式：
    + 行间事件 不推荐
    + head里的script标签 <script type="text/javascript">alert('hello')</script>
    + 外部引入 <script type="text/javascript" src="js/index.js"></script> 推荐
    + html 是从上往下读的
+ 定义变量：var
+ 五种类型：number、string、bool、undefined、null、object
+ 定义变量但不给值就是 undefined；
+ 获取元素：
    + var id1 = document.getElementById('id1')
    + var id2 = document.getElementsByTagName('li') 获取的是一个选择集，不是数组，但是可以用下标的方式操作选择集里面的dom元素.不是数组，不能用数组的方法
    + var id3 = document.querySelector('#div1') 跟的是样式的写法，css中的样式
    + var id4 = document.querySelectorAll('#div1 li') 跟的是样式的写法，css中的样式
```javascript
window.onload = function(){
    var id1 = document.getElementById('id1') //当整个文档加载完后，再执行这个匿名函数。此时放head里没关系了
}
```
+ 操作元素属性：
    + id1.color = 'blue' 可以获取元素后用 . 改变或新增原先没有属性
    + id1.style.fontSize = '30px'  操作 style。注意有 - 的css属性用驼峰式
    + 惟一一个特殊的，把元素的 class 当属性用 id1.className='cls2' 而不是 id1.class
    + 也可以用中括号，中括号的方式可以写变量，也可以写属性 id1['color']
+ innerHTML可以读取或者写入标签包裹的内容
+ 函数：
    + function aa(){}     html标签中 onclick="aa()"  在window.onload中 id1.onclick = aa 不能写括号，写括号就是直接执行了
    + 把函数名绑定到事件上，这样事件一被触发，函数就会执行
+ 变量与函数预解析：先编译后执行。编译阶段会把 var 和 function 定义的提前
+ 匿名函数：没有名称的函数。直接赋给事件
+ 函数传参，接正常来，还有return，也是正常来
+ 运算符：
    + 算数：+ - * / %
    + 条件运算符：== === && || ！
+ 条件语句：if-else if-else   switch-case break 花括号
+ 数组：
    + var arr1 = [1,2,3,'efg']
    + arr1.length
    + arr1[0]
    + arr1.join('-')
    + arr1.push(4)
    + arr1.pop()
    + arr1.unshift(5)
    + arr1.shift()
    + arr1.indexOf(2)
    + arr1.reverse(起始的位置，删除元素的数量，增加的元素1，增加的元素2...)
    + arr1.splice() 在数组中增加或删除元素
+ 循环语句：for(var i=0; i<8; i++){}
```javascript
// 数组去重。遍历，没有的给新数组
var aList = [1,2,3,4,4,3,2,1,2,3,4,5,6,5,5,3,3,4,2,1];

var aList2 = [];

for(var i=0;i<aList.length;i++)
{
    if(aList.indexOf(aList[i])==i)
    {
        aList2.push(aList[i]);
    }
}

alert(aList2);
```
+ 字符串处理方法
    1. 字符串合并操作：“ + ”
    2. parseInt() 将数字字符串转化为整数
    3. parseFloat() 将数字字符串转化为小数
    4. split() 把一个字符串分隔成字符串组成的数组
    5. charAt() 获取字符串中的某一个字符
    6. indexOf() 查找字符串是否含有某字符
    7. substring() 截取字符串 用法： substring(start,end)（不包括end）
    8. toUpperCase() 字符串转大写
    9. toLowerCase() 字符串转小写
+ js中的字符串反转
```javascript
var str = 'asdfj12jlsdkf098';
var str2 = str.split('').reverse().join('');

alert(str2);
```
+ 调试：alert() console.log()
+ isNaN(a)
+ 定时器：
    + setTimeout  只执行一次的定时器  setTimeout(函数名, 毫秒数)
    + clearTimeout 关闭只执行一次的定时器
    + setInterval  反复执行的定时器   setInterval
    + clearInterval 关闭反复执行的定时器
+ JS的内置对象：Date()
+ window.location.href='' 结合倒计时自动更换页面的主页
+ 类型转换：parseInt() parseFloat()
+ 变量作用域：全局变量（函数内外都可访问） 局部变量（仅函数内部可访问） 同名的内部优先
+ 封闭函数的作用，避免加功能的时候，变量之间相互影响
```javascript
// 函数名不用写了，原函数去掉函数名，外面加括号，后面再加一个括号
// 封闭函数就是 两个小括号，第一个括号里写匿名函数 (function(){})(arg);
(function(形参){
    var oDiv = document.getElementById('div1');
    oDiv.style.color = 'red';
})(如果有参数，这边是传参的，把封闭函数赋给变量，用变量调用，实参);  //注意封闭函数后面要加分号
```
+ 封闭函数是读到的时候就会执行。看这个函数的位置，它是不需要调用的
+ 封闭函数前后加分号，可以避免被认为是其它语句的一部分，从而出现问题
+ window.addEventListener('resize', func) resize是一个[监听事件](https://developer.mozilla.org/zh-CN/docs/Web/Events)
+ 闭包（与python中一个意思）
    + 函数的嵌套
    + 外部函数返回内部函数的名字
    + 参数和变量不会被垃圾回收机制回收。即前面我记的环境变量不会消失的意思
    + 作用：可以将变量长期放内存中；私有变量，外部无法访问，只能等它返回
+ 内置对象：
    1. document
        + document.referrer  //获取上一个跳转页面的地址(需要服务器环境)
    2. location
        + window.location.href  //获取或者重定url地址
        + window.location.search //获取地址参数部分
        + window.location.hash //获取页面锚点或者叫哈希值
    3. Math
        + Math.random 获取0-1的随机数
        + Math.floor 向下取整
        + Math.ceil 向上取整
+ JS中的this关键字，谁调用，this就指向谁
+ JS面向对象最好的方式是原型模式 1.新建函数，函数内this给属性 2.外部 函数名(对象名).prototype.方法名 = function(){}
+ 继承：属性用 call 或者 apply 的方式来继承； 方法继承是将父类的一个实例赋值给子类的原型属性

## JQuery
+ 与原生 window.onload 类似的，$(document).ready(function(){}); 简写：$(function(){}); 即 $(匿名函数) 即可
+ jquery中的对象，约定都要在最前面加一个 $。this是原生对象，但$(this)就是jquery对象。普通数值变量不需要
+ jquery选择器：
    + $('css样式') 与在css中选择元素一模一样 $('#id1') $('.cls1') $('ul li')
    + 选择表单元素 $(':password') $(':button')
    + 常规的就两样，还有的选择器，看手册就好了 或者 [这里](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/%E5%89%8D%E7%AB%AF/12/mds/section02.html)
+ 操作css
    + 设置样式：
        + $('#id1').css({fontSize: '30px', color: 'red'});
        + $('#id1').css('color', 'red')
    + 获取样式：
        + $('#id1').css('color')
+ 操作类：
    + $('#id1').addClass('cls2')    加类
    + $('#id1').removeClass('cls2') 移除类（移除多个类，空格隔开）
    + $('#id1').toggleClass('cls2') 切换类，没有就加、有就删去
+ 绑定 click 事件：
```javascript
$('#btn1').click(function(){

    // 内部的this指的是原生对象
    $(this).addClass... // this指的是点击的那个对象，与原生的意思一样，写法格式的不同
    $(this).index() //当前对象的位置索引（和同级比较）
    // 使用jquery对象用 $(this)

})
```
+ jquery选择器用到的：
    + $('div').eq(5); //选择第6个div元素
    + $('div').parent(); //选择div的父元素
    + $('div').children(); //选择div的所有子元素
    + $('div').siblings(); //选择div的同级元素
    + $('div').find('.myClass'); //选择div内的class等于myClass的元素
+ 对象.index() 当前对象的位置索引
+ jquery属性：
    + .html()
        + 读：.html() 直接来
        + 写：.html('<a href='www.baidu.com'>百度</a>') 就是在 html() 括号里面直接写 html
    + .text()
        + 读：.text() 直接来
        + 写：.text('插入到标签里的文字')
    + .attr()
        + 取出：var $src = $('#img1').attr('src');
        + 设置：$('#img1').attr({ src: "test.jpg", alt: "Test Image" }); 设置属性跟设置css样式一样的格式
+ jquery特殊效果：（都还在，只是把display的属性给改了）
    + 淡入淡出：
        + fadeIn()          淡入
        + fadeOut()         淡出
        + fadeToggle()      切换淡入淡出
    + 隐藏显示：
        + hide()            隐藏元素
        + show()            显示元素
        + toggle()          依次展示或隐藏某个元素
    + 展开卷起：
        + slideDown()       向下展开
        + slideUp()         向上卷起
        + slideToggle()     依次展开或卷起某个元素
+ 链式调用：所有jquery对象的方法可以连起来写
+ jquery动画：该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果
    + .animate(css, 毫秒，swing，回调函数)
+ 尺寸位置：[见这里](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/%E5%89%8D%E7%AB%AF/12/mds/section09.html)
+ 回到顶部：获取页面滚动距离，大于某个值时，点击事件触发滚动距离重置，即可实现。网上直接查了用，简单的东西都有源码的
+ jquery事件：[这里](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/%E5%89%8D%E7%AB%AF/13/mds/section00.html)
    + 常用的有:
        + click()
        + mouseover() 前面跟个 stop(),避免重复，使得只最后一次有效
        + mouseout() 前面跟个 stop()
        + mouseenter() 进入子元素不触发
        + mouseleave()
+ 用 bind()函数绑定事件 $(.btn).bind('事件名称'，回调函数) 可以多个事件。
+ 解除绑定事件 $(this).unbind('mouseover')
+ 可以自定义事件，此处跳过
+ 事件冒泡，触发子元素的事件，父元素也会被触发       阻止事件冒泡：event.stopPropagation()
+ 事件都有 event 对象，都是有很多属性的
+ 阻止默认行为：event.preventDefault();
+ 阻止事件冒泡和默认行为的合并写法：return false; 直接在事件触发函数里 return flase 就行了
+ 事件委托，批量一般都用事件委托
```javascript
$(function(){
    $list = $('#list');
    $list.delegate('li', 'click', function(event) {        // .delegate('子元素', '事件名', '事件匿名函数')
        $(this).css({background:'red'});
    });
})
```
+ jquery的节点操作
    + 创建节点 $span = $('<span>span元素</span>')
    + 插入节点
        + 插入元素内部：
            + $('#div1').append($span) 或者 $span.appendTo($('#div1')) 从后面插   append
            + prepend()和prependTo()：在现存元素的内部，从前面插入元素             prepend
        + 插入元素内部
            + after()和insertAfter()：在现存元素的外部，从后面插入元素             after
            + before()和insertBefore()：在现存元素的外部，从前面插入元素           before
    + 删除节点 $('#div1').remove()
+ json格式的数据，其实就是python中的字典的格式，键值一定要用引号，而且一定要是双引号
+ ajax的目的是让 js 发送 http 请求与后台进行通信，获取数据和信息。ajax的通信过程不会影响后续 js 的执行，这即是所谓的异步
+ js中的同步异步和python中是反的，js中同步指的是同时做几件事，异步是一件一件做
+ ajax 可以实现局部刷新（无刷新）
```
$.ajax({
    url: 'js/user.json', //请求地址,ajax只能请求同一个域下的数据或资源
    type: 'GET', //请求方式，默认是'GET'，常用的还有'POST'
    dataType: 'json', //设置返回的数据格式，常用的是'json'格式，也可以设置为'html'
    data:{'aa':1} //data 设置发送给服务器的数据
})
.done(function(data) {
    ......
})
.fail(function() {
    alert('服务器超时，请重试！');
});
```
+ jsonp:jsonp可以跨域请求数据，实现的原理是利用 script 标签可以跨域链接资源的特性
```
<script type="text/javascript">
    function aa(dat){
        alert(dat.name);
    }
</script>
<script type="text/javascript" src="....../js/data.js"></script>

// 页面上定义一个函数，引用一个外部js文件，外部js文件的地址可以是不同域的地址，外部js文件的内容如下
外部js文件内容：aa({"name":"tom","age":18});
```
+ jsonp 的接口就是用括号把数据包起来，然后前面加一个函数名 funcname({json_data});以下是创建自己的 jsonp 接口

```
$.ajax({
    url: 'data.js',
    type: 'GET',
    dataType: 'jsonp',
    jsonpCallback:'aa' // 必须是一个在外部 js 中的对象才行。把 aa 给调过来。那么他就是 data
})
.done(function(data) {
    alert(data.name)
})
.fail(function() {
    alert('服务器超时，请重试！');
});
```
+ 调用别人的jsonp的接口形式：
```
$(function(){
    $('#txt01').keyup(function(){
        var val = $(this).val();
        $.ajax({
            url: 'https://sug.so.360.cn/suggest?',
            type: 'get',
            dataType: 'jsonp',
            data: {word: val} //传给服务器的数据
        })
        .done(function(data) { //data是服务器给的数据

            $('.list').empty();

            for(var i=0;i<data.s.length;i++){
                var $li = $('<li>'+ data.s[i] +'</li>');

                $li.prependTo('.list');
            }

        })
        .fail(function() {
            console.log("error");
        })

    })
})
```
+ 前端用正则做表单验证
+ js中的正则 [用法](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/%E5%89%8D%E7%AB%AF/14/mds/section02.html)
+ 表单验证，套路都一样的，看 register.js 或 网上一大堆
+ cookie，localStorge， localSession
+ jqueryui，zeptojs（移动端的类jquery库），swiper.js（滑动效果库，主要移动端，但也可pc）

## bootstrap[笔记](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/%E5%89%8D%E7%AB%AF/15-16/mds/section03.html)
+ 一般引入三个文件，bootstrap 的 css 和 js 还有 jquery，因为 bootstrap 的js依赖jquery。jquery 要放在 bootstrap js 的前面
+ 实际开发中都是把 css 和 js 放在页面的头部的，文档在放后面是因为 js 的特性，自己加载完后再让别人加载，但实际开发中不这么做
+ 布局容器：（bootstrap需要为页面内容和栅格系统包裹一个容器）
    + .container 类用于固定宽度并支持响应式布局的容器 1170 970 750 100%
    + .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器
+ 栅格系统（用于做响应式的，十二等分）
    + 必须包含在 .row 内，加在一起12的元素就为一行
    + col-lg-  col-md-  col-sm-  col-xs-
    + 栅格里面可以套栅格
    + 可以偏移：类似 col-md-offset-4 中等状态下想右偏移 4 格
```html
<head>

    <title>test</title>
    <link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <style type="text/css">
        div.zhen {
            background-color: #fff;
            height: 200px;
            border: 1px solid #000;
            margin: 5px auto;
            max-width: 200px;
        }
    </style>

</head>

<body>
    <div class='navbar navbar-inverse'>
        <div class='container'>

            <div class='navbar-header'>
                <a href="#" alt='logo'></a>
            </div>

            <ul class='nav navbar-nav'>
                <li><a href="">首页</a></li>
                <li><a href="">关于</a></li>
                <li><a href="">about</a></li>
                <li><a href="">归档</a></li>
            </ul>

            <form class="navbar-form">
                <div class="form-group">
                    <div class="input-group">
                        <input type="text" name="" class="form-control">
                        <span class="input-group-btn">
                            <button class="btn btn-default"></button>
                        </span>
                    </div>
                </div>
            </form>

        </div>
    </div>


    <div class="container">
        <div class="row">
            <div class='col-lg-3 col-md-4 col-sm-6'><div class='zhen'></div></div> //只要是 12 的约数就行了
            <div class='col-lg-3 col-md-4 col-sm-6'><div class='zhen'></div></div> //外层的 div 就是用来布局用的，里面的才是真正的内容
            <div class='col-lg-3 col-md-4 col-sm-6'><div class='zhen'></div></div>
            <div class='col-lg-3 col-md-4 col-sm-6'><div class='zhen'></div></div>
            <div class='col-lg-3 col-md-4 col-sm-6'><div class='zhen'></div></div>
            <div class='col-lg-3 col-md-4 col-sm-6'><div class='zhen'></div></div>
            <div class='col-lg-3 col-md-4 col-sm-6'><div class='zhen'></div></div>
            <div class='col-lg-3 col-md-4 col-sm-6'><div class='zhen'></div></div>
            <div class='col-lg-3 col-md-4 col-sm-6'><div class='zhen'></div></div>
            <div class='col-lg-3 col-md-4 col-sm-6'><div class='zhen'></div></div>
        </div>
    </div>
    <div class="container">
        <div class="btn-group">
            <a href="#" class='btn btn-warning'>按钮1</a>
            <a href="#" class='btn btn-success'>按钮1</a>
            <a href="#" class='btn btn-info'>按钮1</a>
        </div>
    </div>
</body>
```
+ 按钮
    + 可以用的标签 button input a
    + 就是给 class ，bootstrap 会自动给属性
    + btn(声明按钮，这个必须有)    btn-default（默认样式）  其他的样式参考文档
    + 按钮的尺寸：不写是默认状态    大(.btn-lg)  默认 小(.btn-sm) 超小(.btn-xs)
    + 通过给按钮添加 .btn-block 类可以将其拉伸至父元素100%的宽度，而且按钮也变为了块级（block）元素
    + 按钮组，在组件里
+ 表单 很简单，看文档吧
+ 库，只有一种，像 jquery；框架，就是综合的东西
+ 表单组、字体图标（fonts文件夹要有，cdn下好像不用，浏览器应该会自己下载的）
+ 图片：img-responsive 声明响应式图片。最大是图片本身，最小看容器的大小。图片形状也可改，见文档
+ 导航条、路径导航
+ 模态框（js里，事件触发弹框）
+ 下拉菜单
+ 隐藏类（在响应式工具里面，某些屏幕大小状态下不可见）


## MYSQL
+ 不区分大小写
+ 数据库分为
    + 文档型  就是一个文件，sqlit
    + 服务型  服务端，和客户端通过tcp/ip连接，,mysql
+ 数据库都是按照 E-R 模型进行设计的，entry（实体）relationship（关系）
+ 关系描述两个实体之间的对应规则
    + 一对一
    + 一对多
    + 多对多
+ 数据库的三个范式（规则）：
    + 列不可拆分（即这个属性不能往细里分了，按照 E-R 具体看，例如 姓名）
    + 唯一标识（主键）   可以通过一个属性找到唯一的一个对象
    + 引用主键 
+ 数据完整性：一个数据库就是一个完整的业务单元，可以包含多张表，创建表时可以添加一些强制性验证，保证数据的正确有效
+ 字段类型：
    + 数字：int, decimal(浮点数) 使用：decimal(总共位数，小数位数)
    + 字符串：char（自动加空格到指定长度）,varchar（只有最大值，长度可变）,text（大文本）     
    + 日期：datetime（年月日 时分秒） date（年月日）
    + 布尔：bit
+ 约束：
    + primary key   主键（不能重复，唯一标识，查找非常快）
    + not null      非空
    + unique        唯一（不能重复）
    + default       默认（建的时候就设置了，不给就是 x）
    + foreign key   外键 
+ 视频中是用 ubuntu 安装，本地windows连接。我这边还是用的 windows安装，navicat连接
+ 创建数据库：
    + 数据库名随便起，字符集选择 utf-8，排序规则一般选通用
    + 表对应的既是 E-R 模型中的 E，即实体
+ 对表的增删改操作 可以见参考文档 图形界面操作 id不允许空值，且让它自动递增
+ 不要做物理删除，只做逻辑删除。给个 isDelete 栏，默认为 0 没有删除
+ 命令行：
    + 远程登录、退出，此处跳过
    + 数据库操作：
        + 创建数据库: create database 数据库名 charset=utf8;
        + 删除数据库：drop database 数据库名
        + 切换数据库：use 数据库名
        + 查看当前数据库：select database()
        + 显示所有的数据库：show databases；
    + 表操作：
        + 查看所有的表：show tables;
        + 创建表
```mysql
create table 表名(列及类型)；
如：
create table students(
id int auto_increment primary key not null,
name varchar(10) not null,
gender bit default 1,
birthday datetime  //最后不要写逗号，报错
);
```
        + 查看表：desc 表名;
        + 修改表 alter table 表名 add|change|drop 列名 类型;  没必要，一开始就该做好表设计
        + 删除表
        + 表名重命名
    + 数据操作：（增删改查）
        + 查询：select * from 表名
        + 增加数据：insert into 表名 values(有多少字段就要插多少值，id也要随便写一个占位) 其它方式跳过
        + 修改：update students(表名) set birthday='1999-1-1'（数据，可用逗号隔开） where id=2（条件）;  
        + 删除数据：delete from 表名 where id=5; 物理删除
+ 数据备份与恢复，迁移的时候会用到，此处我跳过
+ 总结
    + 创建数据库：create database name1 charset=utf-8
    + 创建表：create table name2 (字段 类型 约数) id int auto_increment primary key not null
    + 增加数据：insert into name2 values()
    + 删除数据：delete from name2 where id=2
    + 修改数据：update name2 set 字段 where id=2

### 查询（重点）
+ 基本：
    + select * from 表名;
    + select name,gender from students; 查询多个列
+ 消除重复行；
    + select distinct gender from students;
    + select distinct id,gender from students; id和gender都不重复，只要有一个不重复就都返回
+ where查询：select * from 表名 where 条件;
    + 比较运算符：= > >= !=
    + 逻辑运算符：and or not
    + 模糊查询(字符匹配)：
        + like：select * from students where sname like '黄%';
        + %：%表示任意多个字符
        + \_: 下划线表示任意一个字符
    + 范围查询；
        + in: select * from students where id in(1,3,8); 查询编号是1或3或8的学生
        + between...and...:select * from students where id between 3 and 8; 在一个连续的范围内
    + 空判断：select * from students where birthday is null 或者 is not null; 注意null和‘’是不同的

+ 聚合：为了快速得到统计数据，提供了5个聚合函数
    + count(\*) `select count(*) from students;` 统计行数
    + max(age)  `select max(id) from students where gender=0;` 最大值
    + min(age)  `select min(id) from students where isdelete=0;` 最小值
    + sum(num)  `select sum(id) from students where gender=1;` 和
    + avg(num)  `select avg(id) from students where isdelete=0 and gender=0;` 平均值
+ 分组：按照字段分组（男生一队，女生一队）
    + 先按字段分组，再按条件 select
    + 一般分组都是为了做聚合
```
select gender,count(*)
from students
group by gender;
```
+ 分组后的数据删选：
```
select gender,count(*)
from students
group by gender
having gender=1;  // having后面的条件运算符与where的相同
```
+ 对比where与having
    + where是对from后面指定的表进行数据筛选，属于对原始数据的筛选
    + having是对group by的结果进行筛选
+ 排序：order by `select * from subject where isdelete=0 order by stitle;`
+ 分页：获取部分行 `select * from 表名 limit start,count` 从 start 开始，获取count条数据
+ 顺序：
```
select distinct *
from 表名
where ....
group by ... having ...
order by ...
limit star,count
```


### 高级部分（视图、事务、索引）
+ 建立关系表：
    + 约束完成检查（建立了关系字段之后，为了保证数据的有效性而添加的一种约束）
    + 外键的级联操作：在删除students表的数据时，如果这个id值在scores中已经存在，则会抛异常。鸡肋功能，用逻辑删除可以避免这种情况
```
create table scores(
id int primary key auto_increment,
stuid int, // 这里已经创建好了
subid int,
score decimal(5,2),
foreign key(stuid) references students(id), // 外键是 stuid，引用的是 students 表中的 id 。此时插入或者修改数据时，如果stuid的值在students表中不存在则会报错
foreign key(subid) references subjects(id)
);
```
+ 连接查询：
    + 郭靖 python 100 来源于多张表
    + students.name;  subjects.title;  scores.score
```
select students.name, subjects.title, scores.score
from scores
inner join students on scores.stuid=student.id
inner join subjects on scores.subid=subjects.id
```
    + 注意 join 和 on 关键字
    + 谁 join 谁没关系，关键是要建立他们的关系
```
select students.name, subjects.title, scores.score
from students
inner join scores on scores.stuid=students.id
inner join subjects on scores.subid=subjects.id; //和上面的结果一样的
```
    + inner left right
        + inner 是两个表都能匹配上的出现
        + left 是两个表都能匹配上的出现，左表特有的也出现，未对应的数据使用null填充
        + right 是两个表都能匹配上的出现，右表特有的也出现

+ 例子；
```
no.1
需求：查询科目的名称、平均分
分析：
    + 需要 subjects.title 和 scores.score 信息
    + 数据来源于两个表，那就要考虑连接问题，那就是 subjects.id=scores.subid
    + 平均分，那就是聚合函数 avg
    + 设计到聚合函数，那就要考虑要不要用 group by
    + 本题需要对科目分组之后求平均分，所以要用 group by
    + 据题意，根据科目的名字进行分组 group by subjects.title

select subjects.title,avg(scores.score)
from scores
inner join subjects on scores.subid=subjects.id
group by subjects.title;


no.2
需求：查询未删除科目的名称、最高分、平均分
分析：
    + 条件：where subjects.isdelete=0
    + 要筛选的 subjects.title max(scores.score) avg(scores.score)
    + 需要连接 subjects.id=scores.subid
    + 也需要分组 group by subjects.title

select subjects.title,max(scores.score),avg(scores.score)
from scores
inner join subjects on subjects.id=scores.subid
where subjects.isdelete=0 //where 要在 group by 的前面
group by subjects.title;
```

+：自关联：表中的某一列，关联了这个表中的另外一列】[here](file:///G:/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/%E9%BB%91%E9%A9%ACpython%E5%B0%B1%E4%B8%9A%E7%8F%AD/%E8%AF%BE%E4%BB%B6%E5%92%8C%E8%B5%84%E6%96%99/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/part3/3.html)
    + 省表，市表，镇表，几张表开销太大，把他们放在一张表里头
    + 下一级比上一级多一个数据，就是上一级的 id
    + 因此就是关联自己，自关联
```
create table areas(
id int primary key,
atitle varchar(20),  // 省和市
pid int, //  省是null，市是省的id值
foreign key(pid) references areas(id)
);
```

+ 视图：为了实现select的多次调用，实现对查询的封装

+ 事务
    + 当一个业务逻辑需要多个sql完成时，如果其中某条sql语句出错，则希望整个操作都退回
    + 使用事务可以完成退回的功能，保证业务逻辑的正确性
    + 一般用不到






























































